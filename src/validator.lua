require("utils")
local argparse = require("argparse")
local sha1 = require("sha1")
local validator = {}
local INTEGRITY_PROTECTION = {
	0x69, 0x53, 0x6f, 0x6c, 0x65, 0x6d, 0x6e, 0x6c,
	0x79, 0x53, 0x77, 0x65, 0x61, 0x72, 0x5f, 0x49,
	0x5f, 0x48, 0x61, 0x76, 0x65, 0x4e, 0x30, 0x74,
	0x42, 0x65, 0x65, 0x6e, 0x54, 0x61, 0x6d, 0x70,
	0x65, 0x72, 0x65, 0x64, 0x57, 0x69, 0x74, 0x68,
	0x5e, 0x36, 0x39, 0x34, 0x32, 0x30, 0x25, 0x21
}
local HEADER_SIGNATURE = [[
; Darkmatter LLVM-IR assembly file
;
; NOTE: This file was generated by the Darkmatter compiler.
; Any edits made may not reflect the original source code,
; and may lead to unpredictable results!
;]]

function validator:init(src_path)
	setmetatable({}, self)
	self.__index = self
	local src = ""

	if not fileExists(src_path) then
		error("File does not exist: " .. src_path)
	end

	self.src = readFile(src_path)
	return self
end

function validator:generateIntegrityHash()
	return generateIntegrityHash(self.src)
end

function validator:getIntegrityHash()
	return getIntegrityHash(self.src)
end

function validator:isValidIntegrityHash()
	return validateIntegrity(self.src)
end

function validator:getCreationTime()
	return getCreationTime(self.src)
end

function validator:getSource()
	return self.src
end

function validator:analyze()
	local results = {}

	-- TODO:
	-- return a table of results
	results["valid_ir"] = {[1] = true}
	results["metadata"] = {[1] = true}
	results["header_signature"] = table.pack(validateHeaderSignature(self.src))
	results["integrity_seal"] = table.pack(validateIntegrity(self.src))

	return results
end

function generateIntegrityHash(src)
	local time, err = getCreationTime(src)
	if not time then
		return false, err
	end

	local current_integrity_hash, err = getIntegrityHash(src)
	if not current_integrity_hash then
		return false, err
	end

	local new_integrity_string = ""

	for _, line in pairs(src:split("\n")) do
		if not line:find("!_DMC_INT = !\"") then
			for _, q in pairs(INTEGRITY_PROTECTION) do
				local s1, s2, s3, s4 = 0, 0, 0, 0

				if #line >= 1 then
					s3 = tonumber(sha1(line):sub(1, 3), 16)
				else
					s3 = 0
				end

				s1 = q + time
				s1 = s1 * 8
				s1 = s1 % 64
				s1 = s1 ^ 3

				s2 = math.floor(time / 3)
				s2 = s2 ^ 2
				s2 = s2 + (s1 % time)
				s2 = s2 - s3

				s4 = bit32.bxor(s1, s2) - s3
				s4 = s4 % 255

				new_integrity_string = new_integrity_string .. string.char(s4)
			end
		end
	end
	
	new_integrity_string = sha1(new_integrity_string)

	return new_integrity_string
end


function validateHeaderSignature(src)
	for i=1, #HEADER_SIGNATURE:split("\n") do
		local line = HEADER_SIGNATURE:split("\n")[i]
		local input = src:split("\n")[i]
		if line ~= input then
			return false, "header signature mismatch, differs at line #" .. i
		end
	end
	return true
end

function getCreationTime(src)
	for line, str in pairs(src:split("\n")) do
		str = str:trim()
		if str:find("!_DMC_DAT = !{u64 ") then
			local date = str:split("!_DMC_DAT = !{u64 ")[2]
			if not date:endsWith("}") then
				break
			end
			date = tonumber(date:split("}")[1])

			if date <= 0 then
				break
			end

			if date >= os.time(os.date("!*t")) then
				return false, "UNIX creation timestamp in metadata is in the future"
			end

			return date
		end
	end
	return false, "malformed UNIX timestamp metadata"
end

function getIntegrityHash(src)
	for line, str in pairs(src:split("\n")) do
		str = str:trim()
		if str:find("!_DMC_INT = !\"") then
			local integrity_hash = str:split("!_DMC_INT = !\"")[2]
			if not integrity_hash:endsWith("\"") then
				break
			end
			integrity_hash = integrity_hash:split("\"")[1]
			if #integrity_hash ~= 40 and #integrity_hash ~= #INTEGRITY_PROTECTION then
				return false, "malformed integrity checksum metadata"
			end

			return integrity_hash
		end
	end
	return false, "malformed integrity checksum metadata"
end

function validateIntegrity(src)

	-- TODO:
	-- 1. copy integrity hash from metadata
	-- 2. replace integrity hash with the INTEGRITY_PROTECTION string
	-- 3. hash entire file
	-- 4. compare integrity hash
	local integrity_hash, err = getIntegrityHash(src)
	if not integrity_hash then
		return false, err
	end
	local generated_integrity_hash, err = generateIntegrityHash(src)
	if not generated_integrity_hash then
		return false, err
	end

	if integrity_hash ~= generated_integrity_hash then
		return false, "integrity broken, assembly has been tampered with"
	end

	return true
end

return validator
